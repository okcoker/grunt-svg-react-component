'use strict';

var path = require('path');
var async = require('async');
var rimraf = require('rimraf');
var chalk = require('chalk');
var SVGO = require('svgo');
var svgo = new SVGO();

module.exports = function(grunt) {

    grunt.registerMultiTask('svg-react-component', 'Create inline SVG React components from svg files', function() {
        var options = this.options({
            ext: '.jsx',
            clean: false,
            svgo: false
        });

        var TEMPLATE = {
            SVG: '{SVG}',
            CLASSNAME: '{CLASSNAME}'
        };

        var COMPONENT = [
            '/**',
            ' * Generated by grunt-svg-react-component',
            ' * https://github.com/okcoker/grunt-svg-react-component',
            ' */',
            '',
            '\'use strict\'',
            '',
            'import React from \'react\';',
            '',
            'class ' + TEMPLATE.CLASSNAME + ' extends React.Component {',
            '    constructor(props) {',
            '        super(props);',
            '    }',
            '',
            '    render() {',
            '        return (',
            '            ' + TEMPLATE.SVG,
            '        );',
            '    }',
            '}',
            '',
            'export default ' + TEMPLATE.CLASSNAME + ';'
        ].join('\n');

        function camelCaseClass(str) {
            var formatted = str.replace(/^([A-Z])|[\s-_](\w)/g, function(match, p1, p2) {
                if (p2) {
                    return p2.toUpperCase();
                }
                return p1.toLowerCase();
            });

            return formatted.charAt(0).toUpperCase() + formatted.substr(1);
        }

        // React doesnt like certain attributes within the SVG
        // when in component files
        function parseSVG(svg) {
            var parsed = svg;
            var replace = [
                // xmlns
                svg.match(/ xmlns:xlink="([^"]*)"/),
                // xml:space
                svg.match(/ xml:space="([^"]*)"/)
            ];

            replace.forEach(function(match) {
                if (match) {
                    parsed = parsed.replace(new RegExp(match[0], 'g'), '');
                }
            });

            return parsed;
        }

        function addPropsToSVG(data) {
            var svg = '<svg';
            var svg_part = data.split(svg)[1];

            if (!svg_part) {
                grunt.log.warn('Something wrong with this svg.');
                return data;
            }

            // Spread props to component
            svg += ' { ...this.props } ';
            svg += svg_part;

            return svg;
        }

        function writeSVG(svg, basename, filename) {
            var template = COMPONENT.replace(new RegExp(TEMPLATE.SVG, 'g'), svg);

            template = template.replace(new RegExp(TEMPLATE.CLASSNAME, 'g'), camelCaseClass(basename));

            grunt.file.write(filename, template);
            grunt.log.ok('File ' + chalk.green(filename) + ' written.');
        }

        async.each(this.files, function(file, next) {
            if (options.clean) {
                rimraf.sync(file.dest + '*', function(err) {
                    if (!err) {
                        return;
                    }

                    grunt.log.warn('File path ' + chalk.red(file.dest) + ' couldn\'t be cleaned.');
                });
            }

            file.src.filter(function(path) {
                if (!grunt.file.exists(path)) {
                    grunt.log.warn('File "' + chalk.yellow(path) + '" not found.');
                    return false;
                }
                else {
                    return true;
                }
            }).map(function(filepath) {
                var buffer = grunt.file.read(filepath);
                var basename = path.basename(filepath, '.svg');
                var filename = file.dest + basename + options.ext;

                if (options.svgo) {
                    svgo.optimize(buffer, function(result) {
                        var data = result.data;
                        var svg;

                        if (result.error) {
                            grunt.log.warn(chalk.yellow(result.error + ' ' + filepath));
                            return;
                        }

                        svg = addPropsToSVG(data);
                        writeSVG(svg, basename, filename);
                    });
                }
                else {
                    // Fallback to basic component parsing
                    var svg = addPropsToSVG(buffer);
                    svg = parseSVG(svg);
                    writeSVG(svg, basename, filename);
                }
            });

            next();
        });
    });
};
